# Lambda Calculus Implementation

## External Interface

The `lc` function is the entry point for the lambda calculus interpreter, and the only external point of contact for the interpreter. It accepts a `str` containing a lambda calculus expression, and returns a `str` with that expression in beta-normal form.

## The Parser

The parser has two pieces of global state:

- `src` - the input string to the parser;
- `i`   - an integer index into `src` marking the next character to be consumed.

The parser generates an abstract syntax tree (AST) from an input `str`. There are three kinds of AST node, which are distinguished by their built-in datatype. There is no class definition:

- Symbols are represented by the single-character string of that symbol - for example `x` is represented by the string `"x"`.
- Applications are represented by a 2-tuple - for example `xy` is represented by `#("x" "y")`.
- Abstractions are represented by a 3-tuple, in which the first element is the string `"λ"` - for example `λx.fx` is represented by `#("λ" "x" #("f" "x"))`.

The parser includes several helper functions:

- `peek` returns the character at `i`, or throws a `RuntimeError` if `i` is passed the end of `src`;
- `next` advances `i` by `1`;
- `is-end` returns a boolean indicating if `i` is passed the end of `src`;
- `spaces` advances `i` passed any whitespace, so that it rests on the next non-whitespace character (or hits the end of the string);
- `ensure-not-end` raises a `RuntimeError` if `i` is passed the end of `src`;
- `ensure-end` raises a `RuntimeError` if `i` is *not* passed the end of `src`;

The parser makes use of these helpers in the main parsing functions.

`parse` accepts a `str` input expression, sets up the global state of the parser, and passes control to `parse-expression`. Once `parse-expression` terminates, `parse` ensures that the whole input has been consumed and returns the AST generated.

`parse-expression` is the main workhorse of the parser. But first, `parse-body`. `parse-body` is called when `i` (should) point to the body of an abstraction. In longhand syntax (`λx.λy. ...`), this will always be a `"."`. In this case, `parse-body` passes control to `parse-expression`. Shorthand syntax (`λxy. ...`) allows a body to begin with a symbol. In this case, `parse-body` calls itself on the remaining body after this symbol, and returns the resulting AST wrapped in a further abstraction with this initial symbol as parameter.

`parse-expression` is called when `i` (should) point to the start of a lambda calculus expression. When encountering a `"("`, we recurse, the closing `")"` is consumed, and the AST generated by the expression within the parentheses is returned. When encontering a `"λ"`, we consume the following symbol, and call out to `parse-body`. A symbol is parsed by simply returning it - it is its own AST node.

Once `parse-expression` has parsed an expression, it inspects the next character that is due to be consumed. If this character corresponds to what we expect at the start of an expression, `parse-expression` recurses on that expression, passing the AST generated so far as the optional argument `lhs`. The recursive call then wraps its own result and `lhs` in an application node. This is to work around the inability of a pure recursive descent parser to handle left recursion.

## Reductions

The `normal-reduce` function, and its helpers `substitute` and `step`, reduce the expression represented by an AST to a beta-normal form through normal reduction steps, if such a normal form exists.

`normal-reduce` takes as an argument an expression (as an AST), and returns the expression that results from completely normal-reducing its input. If this process does not converge to a fixpoint after a limited number of steps, a `RuntimeError` is thrown. `normal-reduce` passes control to `step` to handle each of these reduction steps. 

`step` takes as input an expression (as an AST), and performs one normal reduction step on that expression. It returns the new expression, and a boolean value indicating whether this is different to the original expression. When this value is `False`, `normal-reduce` performs no further reduction steps. Consult any academic source for the semantics of the lambda calculus for details of a normal reduction step.

`substitute` takes as arguments a symbol, a AST substitution for that symbol, and an expression to be modified. It returns its input expression, with all (non-shadowed) occurences of its input symbol substituted for its input substitution. Additionally, it returns `True`, to pass through to the output of `step`; we count any substitution step as changing its expression, even if some expressions (for instance `(λx.xx)(λx.xx)`) do not in fact change after a substitution step. This is because the difference called for by `normal-reduce` is with respect to any reduction steps having been performed, rather then the textual change in an expression.

## Serialisation

The `show` function renders an AST back to a string. This is, for the most part, a simple depth-first traversal of an AST, building up a string representation from the bottom-up. One element of additional complexity is supporting shorthand syntax. When recursing, `show` calls itself with the flag `merge` set to true in the event both its current AST node and its next child are abstractions. This prompts the recursive call to not prepend a `λ` to its result, supporting the shortand syntax. Additionally, `show` will only append a `.` in the case where this does not interfere with the shorthand syntax.
