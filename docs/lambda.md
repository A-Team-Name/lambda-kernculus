# Lambda Calculus Implementation

- entry point `lc`
- parser global state
- utility functions
- parser
    - parse body
    - parse expression
- ast rendering
- reductions
    - substitute
    - normal reductions

## External Interface

The `lc` function is the entry point for the lambda calculus interpreter, and the only external point of contact for the interpreter. It accepts a `str` containing a lambda calculus expression, and returns a `str` with that expression in beta-normal form.

## The Parser

The parser has two pieces of global state:

- `src` - the input string to the parser;
- `i`   - an integer index into `src` marking the next character to be consumed.

The parser generates an abstract syntax tree (AST) from an input `str`. There are three kinds of AST node, which are distinguished by their built-in datatype. There is no class definition:

- Symbols are represented by the single-character string of that symbol - for example `x` is represented by the string `"x"`.
- Applications are represented by a 2-tuple - for example `xy` is represented by `#("x" "y")`.
- Abstractions are represented by a 3-tuple, in which the first element is the string `"λ"` - for example `λx.fx` is represented by `#("λ" "x" #("f" "x"))`.

The parser includes several helper functions:

- `peek` returns the character at `i`, or throws a `RuntimeError` if `i` is passed the end of `src`;
- `next` advances `i` by `1`;
- `is-end` returns a boolean indicating if `i` is passed the end of `src`;
- `spaces` advances `i` passed any whitespace, so that it rests on the next non-whitespace character (or hits the end of the string);
- `ensure-not-end` raises a `RuntimeError` if `i` is passed the end of `src`;
- `ensure-end` raises a `RuntimeError` if `i` is *not* passed the end of `src`;

The parser makes use of these helpers in the main parsing functions.

`parse` accepts a `str` input expression, sets up the global state of the parser, and passes control to `parse-expression`. Once `parse-expression` terminates, `parse` ensures that the whole input has been consumed and returns the AST generated.

`parse-expression` is the main workhorse of the parser. But first, `parse-body`. `parse-body` is called when `i` (should) point to the body of an abstraction. In longhand syntax (`λx.λy. ...`), this will always be a `"."`. In this case, `parse-body` passes control to `parse-expression`. Shorthand syntax (`λxy. ...`) allows a body to begin with a symbol. In this case, `parse-body` calls itself on the remaining body after this symbol, and returns the resulting AST wrapped in a further abstraction with this initial symbol as parameter.

`parse-expression` is called when `i` (should) point to the start of a lambda calculus expression. When encountering a `"("`, we recurse, the closing `")"` is consumed, and the AST generated by the expression within the parentheses is returned. When encontering a `"λ"`, we consume the following symbol, and call out to `parse-body`. A symbol is parsed by simply returning it - it is its own AST node.

Once `parse-expression` has parsed an expression, it inspects the next character that is due to be consumed. If this character corresponds to what we expect at the start of an expression, `parse-expression` recurses on that expression, passing the AST generated so far as the optional argument `lhs`. The recursive call then wraps its own result and `lhs` in an application node. This is to work around the inability of a pure recursive descent parser to handle left recursion.

## Reductions



